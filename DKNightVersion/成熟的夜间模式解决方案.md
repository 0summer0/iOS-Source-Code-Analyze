# 成熟的夜间模式解决方案

从开始写 [DKNightVersion](https://github.com/Draveness/DKNightVersion) 这个框架到现在已经将近一年了，目前整个框架的设计也趋于稳定，其实夜间模式的实现就是相当于**多主题和颜色管理**。而最新版本的 [DKNightVersion](https://github.com/Draveness/DKNightVersion) 已经很好的解决了这个问题。

在正式介绍目前版本的实现之前，我会先简单介绍一下 1.0 时代的 DKNightVersion 的实现，为各位读者带来一些新的思路，也确实想梳理一下这个框架是如何演变的。

> 我们会以对 `backgroundColor` 为例说明整个框架的工作原理

## 方法调剂的版本

而如何在不改变原有的架构，甚至不改变原有的代码的基础上，就能为应用优雅地添加夜间模式就成为一个在很多应用开发的过程中不得不面对的一个问题。这也是 1.0 时代的 DKNightVersion 想要实现的目标。

### 使用 nightBackgroundColor

在思考之后，我想到，想要在不改动原有代码的基础上实现夜间模式只能通过在**分类**中添加 `nightBackgroundColor` 这种属性，并且使用方法调剂改变 `backgroundColor` 的 setter 方法。

```objectivec
- (void)hook_setBackgroundColor:(UIColor*)backgroundColor {
    if ([DKNightVersionManager currentThemeVersion] == DKThemeVersionNormal) {
        [self setNormalBackgroundColor:backgroundColor];
    }
    [self hook_setBackgroundColor:backgroundColor];
}
```

在当前主题为 `DKThemeVersionNormal` 时，将颜色保存至 `normalBackgroundColor` 属性中，然后在调用原 `backgroundColor` 的 setter 方法，更新视图的颜色。

这时，如果我们在全局修改整个应用的主题时，并不会立刻更新整个应用的颜色。

整个 DKNightVersion 都是由一个 DKNightVersionManager 的单例来管理的，而它的主要只能就是负责改变整个应用的主题、并在主题发生改变时使其它视图更新颜色：

```objectivec
- (void)changeColor:(id <DKNightVersionChangeColorProtocol>)object {
    if ([object respondsToSelector:@selector(changeColor)]) {
        [object changeColor];
    }
    if ([object respondsToSelector:@selector(subviews)]) {
        if (![object subviews]) {
            // Basic case, do nothing.
            return;
        } else {
            for (id subview in [object subviews]) {
                // recursive darken all the subviews of current view.
                [self changeColor:subview];
                if ([subview respondsToSelector:@selector(changeColor)]) {
                    [subview changeColor];
                }
            }
        }
    }
}
```

如果主题更新，那么就会递归地调用 `changeColor:` 方法，刷新全部的视图颜色，而这个方法的实现实在是太过简单：

```objectivec
- (void)changeColor {
    if ([DKNightVersionManager currentThemeVersion] == DKThemeVersionNormal) {
        self.backgroundColor = self.normalBackgroundColor;
    } else {
        self.backgroundColor = self.nightBackgroundColor;
    }
}
```

上面就是整个框架在 1.0 版本时的实现思路。不过这个版本的 DKNightVersion 在实际应用中会有比较多的问题：

1. 在高速滚动的 `scrollView` 上面来回切换夜间模式，会出现颜色错乱的问题
2. 由于对 `backgroundColor` 属性进行**不合适的**方法调剂，其行为无法预测
2. 无法适配第三方 UI 控件

## 使用色表的版本

为了解决 1.0 中的各种问题，我决定在 2.0 版本中放弃对 `nightBackgroundColor` 的使用，并且重新设计底层的实现，转而使用更为**稳定**、**安全**的方法实现夜间模式，先看一下效果图：

<p align='center'>![DKNightVersion-Demo](https://raw.githubusercontent.com/Draveness/DKNightVersion/master/images/DKNightVersion.gif)

### DKColorPicker

与上一个版本实现上的不同，在 2.0 中删除了全部的 `nightBackgroundColor`，使用一个名为 `dk_backgroundColorPicker` 的属性取代它。

```objectivec
@property (nonatomic, copy) DKColorPicker dk_backgroundColorPicker;
```

这个属性其实就是一个 block，它接收参数 `DKThemeVersion *themeVersion`，但是会返回一个 `UIColor *`：

```objectivec
typedef UIColor *(^DKColorPicker)(DKThemeVersion *themeVersion);
```

比如使用 `DKColorPickerWithRGB` 创建一个临时的 `DKColorPicker`：

1. 在 `DKThemVersionNormal` 时返回 `0xffffff`
2. 在 `DKThemeVersionNight` 时返回 `0x343434`
3. 在自定义的主题 `RED` 下返回 `0xfafafa`

```objectivec
cell.dk_backgroundColorPicker = DKColorPickerWithRGB(0xffffff, 0x343434, 0xfafafa);
```

同时，每一个对象还持有一个 `pickers` 数组，来存储自己的全部 `DKColorPicker`：

```objectivec
@interface NSObject ()

@property (nonatomic, strong) NSMutableDictionary<NSString *, DKColorPicker> *pickers;

@end
```

在第一次使用这个属性时，会将当前对象注册为 `DKNightVersionThemeChangingNotificaiton` 的通知。

在每次收到通知时，都会调用 `night_update` 方法，将当前主题传入 `DKColorPicker`，并再次执行。

```objectivec
- (void)night_updateColor {
    [self.pickers enumerateKeysAndObjectsUsingBlock:^(NSString * _Nonnull selector, DKColorPicker  _Nonnull picker, BOOL * _Nonnull stop) {
        SEL sel = NSSelectorFromString(selector);
        id result = picker(self.dk_manager.themeVersion);
        [UIView animateWithDuration:DKNightVersionAnimationDuration
                         animations:^{
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
                             [self performSelector:sel withObject:result];
#pragma clang diagnostic pop
                         }];
    }];
}
```

也就是说，在每次改变主题的时候，都会发出通知。

### DKColorTable

虽然我们在上面临时创建了一些 `DKColorPicker`，不过在 `DKNightVersion` 中，我更推荐使用色表，来减少相同的 `DKColorPicker` 的创建，并且能够更好地管理整个应用中的颜色：

```objectivec
NORMAL   NIGHT    RED
#ffffff  #343434  #fafafa BG
#aaaaaa  #313131  #aaaaaa SEP
#0000ff  #ffffff  #fa0000 TINT
#000000  #ffffff  #000000 TEXT
#ffffff  #444444  #ffffff BAR
```

上面就是默认色表文件 `DKColorTable.txt` 中的内容，其中，第一行表示主题，`NORMAL` 主题必须存在，而且必须为第一行，而最右面的 `BG`、`SEP` 就是对应 `DKColorPicker` 的 key。

```objectivec
self.tableView.dk_backgroundColorPicker =  DKColorPickerWithKey(BG);
```

在使用时，上面的代码就相当于返回了一个在 `NORMAL` 时返回 `#ffffff`、`NIGHT` 时返回 `#343434` 以及 `RED` 时返回 `#fafafa` 的 `DKColorPicker`。

### pickerify

虽然说，我们使用色表以及 `DKColorPicker` 解决了




> 关注仓库，及时获得更新：[iOS-Source-Code-Analyze](https://github.com/draveness/iOS-Source-Code-Analyze)
> Follow: [Draveness · Github](https://github.com/Draveness)


